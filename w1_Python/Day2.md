## 변수
값을 저장하는 저장소

변수는 메모리 주소를 가지고 있고, 변수에 들어가는 값은 메모리 주소에 할당된다.

> 폰노이만 아키텍처에서는 프로그램 실행 시 정보를 먼저 메모리에 저장시키고, CPU가 순차적으로 그 정보를 해석하고 계산하여 결과를 낸다 
> ( 프로세스 메모리에 적재 -> PC 대로 명령어 읽어와 순차 실행? )



## 동적 타이핑
자바 같은 경우 변수 선언 시 Integer와 같이 변수 타입을 지정해준다.

그러나 파이썬에서는 **변수 타입을 정하지 않고, 실행하는 시점에서 인터프리터가 판단하여 해석**한다.

컴파일 언어 같은 경우엔 이미 변수 타입을 알기에 컴파일 시 컴퓨터가 메모리 공간을 잡아 놓는다

그러나 인터프리터 언어는 실행 당시에 메모리 공간을 잡아야 하기에 속도가 조금 늦어지는 단점

(컴파일 언어 경우에도 실행 당시에 메모리 잡지만?, 이미 변수타입으로 메모리 크기 예상하고 있기에 더 빠르다)



## 컴퓨터 반올림 오차

이진수로 값을 저장하기에 단순한 실수도 무한 소수가 되어버림.



## 리스트 카피

```
a = b[:] #1차원 리스트
a = copy.deepcopy(b) # 2차원 리스트
```

리스트의 메모리 구조가 기본의 것들과 좀 다르다 보니 복사할 때, 그냥 할당하는 방식을 사용하면 복사가 안된다.

> 리스트로 잡혀있는 메모리 안에 값이 들어있는게 아니라. 실제 데이터가 있는 주소를 담고 있다.

파이썬에서 **a = b를 하면 메모리 참조**가 이뤄나는 것이다. 

**메모리 참조와 복사의 차이를 이해해라.**




## 함수
* 반복되는 코드를 제거할 수 있다.

* 코드를 논리적 단위로 나눠준다.

* 캡슐화 기능 

  > 인터페이스만 알면 타인의 코드 사용 가능

* 함수가 정의 되면 메모리에 올라가게 된다. (앞에 써주는게 좋다)

  > 애초에 코드영역이 메모리에 올라가니까 당연?




## formatting



### 1. %-formatting

```
print("Product : %(name)10s , Price : %(price).5f" % {"name":"A", "price":4.5})
```

* %5d : 5칸을 만들어놔라

* %8.2f : 8칸 만들어 놓고, 소수점 둘째 자리까지만 출력

* <10s : 10칸을 만들어 놓고, 왼쪽으로 정렬하라.

* %(name)10s : name이라는 변수?를 가져와서 넣는다 (딕셔너리를 출력할 때 사용)



## 2. f-string (요즘 대세)

```
print(f"Hello, {name}. You are {age}.")
```
* name, age라는 변수가 바로 들어감.

* {name:20} : 20칸 만든다

* {name:>20} : 오른쪽 정렬

* {name:^20} : 가운데 정렬

* {number:.2f} : 소수점 둘째 자리까지 출력




## is 연산
변수가 가리키고 있는 **메모리의 주소가 같은지**를 비교.

> 값만 같다면 False



```
a = [1,2,3,4,5]
b = a[:] # deepcopy
c = a    # 참조
a is b # False
a is c # True
```



파이썬은 예전에 속도를 위해서 -5 ~ 256까지는 파이썬 실행되는 순간에 메모리 공간에 이 숫자를 저장해놈

a = 5와 같이 상수를 할당하더라도 메모리 상에 5가 들어갈 공간을 새로 잡지 않고, 초기에 잡아놓은 공간을 가리키기만 한다.

그러나 a = 300과 같이 값을 할당한다면 300을 할당할 때마다 메모리 공간에 새로운 300을 위한 메모리가 계속 만들어지고 새로 만들어진 300을 가리킨다.

```
a = 5 
b = 5
a is b => True

a = 300
b = 300
a is b => False
```



## STRING

컴퓨터는 모든 데이터를 2진수로 인식

이진수 덩어리를 문자로 표현하기 위해 표준 규칙을 정함 -> ASCII, UNICODE

> ex) "U" -> 이진수 1000011 (UTF-8 기준)




## Call by Object Reference

파이썬은 **객체의 주소**가 함수로 전달된다.

*-- call by reference와 정확히 무슨 차이?? --*

되도록이면 함수 호출할 때, 파라미터로 들어온 값 자체를 바꾸지 않고 

다른 변수에 복사해놓고 그 변수를 바꾸는게 좋다.



## fuction type hints
```
def function(var_name : var_type) -> return_type :

def function(name : str) -> int :
```

사용자에게 인터페이스를 명확히 알려줄 수 있다.

paramter에 대한 정보를 명확해진다.



## fuction doc string
파이썬 함수에 대한 상세 스펙을 사전에 작성 -> 사용자 이해도 상승

**docstring 작성하는 것을 습관화 해라.**

```
def add_Binary(a,b) : 
	'''
	Returns the sum of two decimal numbers in binary digits.
	
	Parameters : 
		a (int) : A decimal interger
		b (int) : Another decimal integer
	
	Returns :
		binary_sum (str) : binary string of the sum of a and b
	'''
```



## 함수 작성 가이드 라인

1. 함수는 가능하면 짧게 작성할 것 (줄 수를 줄일 것)
   * 짧게 여러개를 작성해서 프로그램을 만든다.
2. 이름에 함수의 역할, 의도를 명확히 들어낼 것
3. 인자로 받은 값 자체를 바꾸지 말아라 
   * 임시 변수를 만들어 복사한 뒤 사용해라
4. 복잡한 수식은 함수화 해라
5. 복잡한 조건은 함수화 해라



**컴퓨터가 이해할 수 있는 코드는 어느 바보나 다 짤 수 있다.**

**좋은 프로그래머는 사람이 이해할 수 있는 코드를 짠다.** 

> 코딩 컨베션 (구글 파이썬 코드 컨벤션 읽어보라)



불필요한 공백은 피하라

함수명은 가능한 소문자로 구성하고 필요하면 밑줄로 나눈다

변수, 함수명은 snake_case    클래스는 CamelCase




## black
black을 사용하면 PEP8 컨벤션에 맞게 코드를 수정해준다.

```
conda install black
black test.py 
```



## 리스트 슬라이싱

a[::2] : 두칸 단위로 뛴다

a[::-1] : 문자열이 리버스 된다 (역슬라이싱)



list comprehension은 단일로 사용될 때만 가독성이 좋다

두개 이상이 겹쳐진다면 오히려 가독성을 떨어트린다.

**list comprehension이 속도 측면에서 좀 더 빠르다고 한다.**